/**
 * Copyright 2019-2021 Huawei Technologies Co., Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
include "ops_types.fbs";

namespace mindspore.schema;

table Abs {
}

table Activation {
    activation_type: ActivationType = 0;
    alpha: float;
    min_val: float;
    max_val: float;
}

table ActivationGrad {
    type: ActivationType;
    alpha: float;
}

table Adam {
    use_locking: bool;
    use_nesterov: bool;
}

table AddFusion {
    activation_type: ActivationType = 0;
}

table AdderFusion {
    format: Format = 0;
    kernel_size: [long];
    stride: [long];
    dilation: [long];
    pad_mode: PadMode;
    pad_list: [long];
    group: long;
    in_channel: long;
    out_channel: long;
    activation_type: ActivationType = 0;
}

table AddGrad {
}

table AddN {
}

table All {
    keep_dims: long;
}

table ApplyMomentum {
    use_nesterov: bool;
    use_locking: bool;
    gradient_scale: float;
}

table ArgMaxFusion {
    axis: long;
    top_k: long = 1;
    keep_dims: bool;
    out_max_value: bool;
}

table ArgMinFusion {
    axis: long;
    top_k: long;
    keep_dims: bool;
    out_max_value: bool;
}

table Assert {
    summarize: long;
}

table Assign {
}

table AssignAdd {
}

table AudioSpectrogram {
    window_size: long;
    stride: long;
    mag_square: bool;
}

table AvgPoolFusion {
    kernel_size: [long];
    strides: [long];
    pad: [long];
    pad_mode: PadMode;
    round_mode: RoundMode;
    format: Format;
    global: bool;
    activation_type: ActivationType = 0;
}

table BatchNorm {
    epsilon: float;
    format: Format;
    is_training: bool;
}

table BatchNormGrad {
    epsilon: float;
}

table BatchToSpace {
    block_size: [long];
    crops: Vec2D;
}

table BatchToSpaceND {
    block_shape: [long];
    crops: Vec2D;
}

table BiasAdd {
    format: Format;
}

table BinaryCrossEntropy {
    reduction: Reduction;
}

table BinaryCrossEntropyGrad {
    reduction: Reduction = 1;
}

table BiasGrad {
}

table BroadcastTo {
    shape: [long];
}

table Cast {
}

table Ceil {
}

table Clip {
    max: float;
    min: float;
}

table Concat {
    axis: long;
}

table ControlDepend {
    depend_mode: long;
}

table Conv2DBackpropFilterFusion {
    format: Format = 0;
    kernel_size: [long];
    stride: [long];
    dilation: [long];
    pad_mode: PadMode;
    pad_list: [long];
    mode: long;
    group: long;
    in_channel: long;
    out_channel: long;
    activation_type: ActivationType = 0;
}

table Conv2DBackpropInputFusion {
    format: Format = 0;
    kernel_size: [long];
    stride: [long];
    dilation: [long];
    pad_mode: PadMode;
    pad: [long];
    pad_list: [long];
    mode: long;
    group: long;
    in_channel: long;
    out_channel: long;
    activation_type: ActivationType = 0;
}

table Conv2DFusion {
    format: Format = 0;
    kernel_size: [long];
    stride: [long];
    dilation: [long];
    pad_mode: PadMode;
    pad_list: [long];
    mode: long;
    group: long;
    in_channel: long;
    out_channel: long;
    activation_type: ActivationType = 0;
}

table Conv2dTransposeFusion {
    format: Format = 0;
    kernel_size: [long];
    stride: [long];
    dilation: [long];
    pad_mode: PadMode;
    pad: [long];
    pad_list: [long];
    mode: long;
    group: long;
    in_channel: long;
    out_channel: long;
    activation_type: ActivationType = 0;
}

table Cos {
}

table ConstantOfShape {
    data_type: long;
    value: [float];
}

table Crop {
    axis: long;
    offsets: [long];
}

table CustomExtractFeatures {
}

table CustomNormalize {
}

table CustomPredict {
    output_num: long;
    weight_threshold: float;
}

table Depend {
}

table DepthToSpace {
    block_size: long;
    format: Format = 0;
}

table DetectionPostProcess {
    format: Format = 0;
    input_size: long;
    scale: [float];
    nms_iou_threshold: float;
    nms_score_threshold: float;
    max_detections: long;
    detections_per_class: long;
    max_classes_per_detection: long;
    num_classes: long;
    use_regular_nms: bool;
    out_quantized: bool;
}

table DivFusion {
    activation_type: ActivationType = 0;
}

table DivGrad {
}

table Dropout {
    keep_prob: float = 0.5;
}

table DropoutGrad {
    ratio: float;
}

table Elu {
    alpha: float;
}

table Eltwise {
    mode: EltwiseMode;
}

table Equal {
}

table EmbeddingLookupFusion {
    max_norm: float;
}

table ExpFusion {
    base: float = -1;
    scale: float = 1.0;
    shift: float = 0.0;
}

table ExpandDims {
}

table FakeQuantWithMinMaxVars {
    num_bits: long;
    narrow_range: bool;
}

table FakeQuantWithMinMaxVarsPerChannel {
    num_bits: long;
    narrow_range: bool;
}

table FftReal {
}

table FftImag {
}

table Flatten {
}

table FlattenGrad {
}

table Floor {
}

table FloorDiv {
}

table FloorMod {
}

table Fill {
}

table FullConnection {
    has_bias: bool;
    use_axis: bool;
    axis: long;
    activation_type: ActivationType = 0;
}

table FusedBatchNorm {
    epsilon: float = 0.0001;
    momentum: float = 0.9;
    mode: long;
}

table Gather {
}

table GatherNd {
}

table Greater {
}

table GreaterEqual {
}

table HashtableLookup {
}

table InstanceNorm {
    epsilon: float;
}

table LayerNormFusion {
    begin_norm_axis: long;
    epsilon: float = 0.00001;
    elementwise_affine: bool;
    begin_params_axis: long;
}

table LeakyRelu {
    negative_slope: float;
}

table Less {
}

table LessEqual {
}

table Log {
}

table LogGrad {
}

table LogicalAnd {
}

table LogicalNot {
}

table LogicalOr {
}

table LpNormalization {
    axis: long;
    p: long;
}

table Lrn {
    depth_radius: long;
    bias: float;
    alpha: float;
    beta: float;
    norm_region: string;
}

table LshProjection {
    type: LshProjectionType;
}

table LSTM {
    bidirectional: bool;
    has_bias: bool;
    input_size: long;
    hidden_size: long;
    num_layers: long;
    num_directions: long;
    dropout: float;
}

table L2NormalizeFusion {
    axis: [long];
    epsilon: float;
    activation_type: ActivationType = 0;
}

table MatMul {
    transpose_a: bool = false;
    transpose_b: bool = false;
}

table Maximum {
}

table MaximumGrad {
    grad_x: bool;
    grad_y: bool;
}

table MaxPoolFusion {
    kernel_size: [long];
    strides: [long];
    pad: [long];
    pad_mode: PadMode;
    round_mode: RoundMode;
    format: Format;
    global: bool;
    activation_type: ActivationType = 0;
}

table Merge {
}

table Mfcc {
    freq_upper_limit: float;
    freq_lower_limit: float;
    filter_bank_channel_num: long;
    dct_coeff_num: long;
}

table Minimum {
}

table MinimumGrad {
    grad_x: bool;
    grad_y: bool;
}

table Mod {
}

table MulFusion {
    activation_type: ActivationType = 0;
}

table MulGrad {
}

table Neg {
}

table NegGrad {
}

table NotEqual {
}

table NonMaxSuppression {
    center_point_box: long;
}

table OneHot {
    axis: long;
}

table OnesLike {
}

table PadFusion {
    paddings: Vec2D;
    padding_mode: PaddingMode;
    constant_value: float;
}

table PartialFusion {
    sub_graph_index: long;
}

table DeConv2DGradFilter {
    in_channel: long;
    out_channel: long;
    kernel_size: [long];
    pad_mode: PadMode;
    pad_list: [long];
    stride: [long];
    dilation: [long];
    group: long;
    format: Format;
    activation_type: ActivationType;
}

table PoolingGrad {
    format: Format = 0;
    pool_mode: PoolMode;
    global: bool;
    window: [long];
    stride: [long];
    pad_mode: PadMode;
    pad_list: [long];
    round_mode: RoundMode;
}

table PowerGrad {
    power: float;
    scale: float;
    shift: float;
}

table PowFusion {
    scale: float;
    shift: float;
}

table PriorBox {
    min_sizes: [long];
    max_sizes: [long];
    aspect_ratios: [float];
    variances: [float];
    image_size_w: long;
    image_size_h: long;
    step_w: float;
    step_h: float;
    clip: bool;
    flip: bool;
    offset: float;
}

table PReLUFusion {
    channel_shared: bool;
}

table Rank {
}

table Range {
    d_type: long;
    start: long;
    limit: long;
    delta: long = 1;
}

table Reciprocal {
}

table RealDiv {
}

table ReduceFusion {
    keep_dims: bool;
    mode: ReduceMode;
    reduce_to_end: bool;
    coeff: float;
}

table Reshape {
}

table Resize {
    format: Format = 0;
    method: ResizeMethod;
    new_height: long;
    new_width: long;
    preserve_aspect_ratio: bool = false;
    coordinate_transform_mode: CoordinateTransformMode;
    cubic_coeff: float;
    exclude_outside: long;
    extrapolation_value: float;
    nearest_mode: NearestMode;
}

table ReverseSequence {
    seq_dim: long;
    batch_dim: long;
}

table ReverseV2 {
    axis: [long];
}

table Rfft {
    fft_length: long;
}

table ROIPooling {
    pooled_h: long;
    pooled_w: long;
    scale: float;
}

table Round {
}

table Rsqrt {
}

table QuantDTypeCast {
    src_t: long;
    dst_t: long;
}

table ScaleFusion {
    axis: long;
    activation_type: ActivationType = 0;
}

table ScatterNd {
}

table SGD {
    nesterov: bool;
    dampening: float;
    weight_decay: float;
}

table Shape {
}

table SigmoidCrossEntropyWithLogits {
}

table SigmoidCrossEntropyWithLogitsGrad {
}

table Sin {
}

table SkipGram {
    include_all_grams: bool;
    max_skip_size: long;
    ngram_size: long;
}

table SliceFusion {
    axes: [long];
}

table SmoothL1Loss {
    beta: float;
}

table SmoothL1LossGrad {
    beta: float;
}

table Softmax {
    axis: [long];
}

table SoftmaxCrossEntropyWithLogits {
}

table SpaceToBatch {
    block_size: [long];
    paddings: Vec2D;
}

table SpaceToBatchND {
    block_shape: [long];
    paddings: Vec2D;
}

table SpaceToDepth {
    block_size: long;
    format: Format;
}

table SparseSoftmaxCrossEntropy {
    grad: bool;
}

table SparseToDense {
}

table Split {
    output_num: long;
    size_splits: [long];
    axis: long;
}

table Sqrt {
}

table Squeeze {
    axis: [long];
}

table Square {
}

table SquaredDifference {
}

table Stack {
    axis: [long];
}

table StridedSlice {
    begin_mask: long;
    end_mask: long;
    ellipsis_mask: long;
    new_axis_mask: long;
    shrink_axis_mask: long;
}

table SubFusion {
    activation_type: ActivationType = 0;
}

table SubGrad {
}

table Switch {
}

table TensorListFromTensor {
    element_dtype: long;
    shape_type: long;
}

table TensorListGetItem {
    element_dtype: long;
}

table TensorListReserve {
    element_dtype: long;
    shape_type: long;
}

table TensorListSetItem {
    element_dtype: long;
}

table TensorListStack {
    num_elements: long;
    element_dtype: long;
}

table TileFusion {
    dims: [long];
}

table TopKFusion {
    sorted: bool = true;
    axis: long;
    largest: long;
}

table Transpose {
}

table Unique {
}

table Unpack {
    axis: long = 0;
}

table UnsortedSegmentSum {
}

table Unsqueeze {
    axis: [long];
}

table While {
    cond_subgraph_index: long;
    body_subgraph_index: long;
}

table Where {
}

table ZerosLike {
}

